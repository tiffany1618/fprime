<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Svc::ComQueue Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">Latest</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_svc_com_queue_component.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a> Component </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md339"></a>
Svc::ComQueue (Active Component)</h1>
<h2><a class="anchor" id="autotoc_md340"></a>
1. Introduction</h2>
<p><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> is an F´ active component that functions as a priority queue of buffer types. Messages are dequeued and forwarded when a <code>Fw::Success::SUCCESS</code> signal is received in order of priority. <code>Fw::Success::FAILURE</code> signals result in the queues being paused until a following <code>Fw::Success::SUCCESS</code> signal.</p>
<p><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> is configured with a queue depth and queue priority for each incoming <code>Fw::Com</code> and <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> port by passing in a configuration table at initialization. Queued messages from the highest priority source port are serviced first and a round-robin algorithm is used to balance between ports of shared priority.</p>
<p><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> is designed to act alongside instances of the <a href="https://nasa.github.io/fprime/Design/communication-adapter-interface.html">communication adapter interface</a> and implements the communication queue <a href="https://nasa.github.io/fprime/Design/communication-adapter-interface.html#communication-queue-protocol">protocol</a>.</p>
<h2><a class="anchor" id="autotoc_md341"></a>
2. Assumptions</h2>
<ol type="1">
<li>Incoming buffers to a given port are in priority order</li>
<li>Data is considered to be successfully sent when a <code>Fw::Success::SUCCESS</code> signal was received</li>
<li>The com adapter is responsible for any retransmission of failed data</li>
<li>The system includes downstream components implementing the <a href="https://nasa.github.io/fprime/Design/communication-adapter-interface.html">communications adapter</a></li>
</ol>
<h2><a class="anchor" id="autotoc_md342"></a>
3. Requirements</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Requirement   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Rationale   </th><th class="markdownTableHeadNone">Verification Method    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-COMQUEUE-001   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> shall queue <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> and <code><a class="el" href="class_fw_1_1_com_buffer.html">Fw::ComBuffer</a></code> received on incoming ports.   </td><td class="markdownTableBodyNone">The purpose of the queue is to store messages.   </td><td class="markdownTableBodyNone">Unit Test    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SVC-COMQUEUE-002   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> shall output exactly one <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> or <code><a class="el" href="class_fw_1_1_com_buffer.html">Fw::ComBuffer</a></code> message on a received <code>Fw::Success::SUCCESS</code> signal.   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> obeys the communication adapter interface protocol.   </td><td class="markdownTableBodyNone">Unit Test    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-COMQUEUE-003   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> shall pause sending on the <code>Fw::Success::FAILURE</code> and restart on the next <code>Fw::Success::SUCCESS</code> signal.   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> should not sent to a failing communication adapter.   </td><td class="markdownTableBodyNone">Unit Test    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SVC-COMQUEUE-004   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> shall have a configurable number of <code>Fw::Com</code> and <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> input ports.   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> should be adaptable for a number of projects.   </td><td class="markdownTableBodyNone">Inspection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-COMQUEUE-005   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> shall select and send the next priority <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> and <code><a class="el" href="class_fw_1_1_com_buffer.html">Fw::ComBuffer</a></code> message in response to <code>Fw::Success::SUCCESS</code>.   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> obeys the communication adapter interface protocol.   </td><td class="markdownTableBodyNone">Unit test    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SVC-COMQUEUE-006   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> shall periodically telemeter the number of queued messages per-port in response to a <code>run</code> port invocation.   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> should provide useful telemetry.   </td><td class="markdownTableBodyNone">Unit Test    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-COMQUEUE-007   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> shall emit a queue overflow event for a given port when the configured depth is exceeded. Messages shall be discarded.   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> needs to indicate off-nominal events.   </td><td class="markdownTableBodyNone">Unit Test    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SVC-COMQUEUE-008   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> shall implement a round robin approach to balance between ports of the same priority.   </td><td class="markdownTableBodyNone">Allows projects to balance between a set of queues of similar priority.   </td><td class="markdownTableBodyNone">Unit Test    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-COMQUEUE-009   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> shall keep track and throttle queue overflow events per port.   </td><td class="markdownTableBodyNone">Prevents a flood of queue overflow events.   </td><td class="markdownTableBodyNone">Unit test   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md343"></a>
4. Design</h2>
<p>The diagram below shows the <code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> component.</p>
<p><img src="./img/ComQueue.png" alt="Svc::ComQueue" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md344"></a>
4.1. Ports</h3>
<p><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> has the following ports:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Kind   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Port Type   </th><th class="markdownTableHeadNone">Usage    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output</code>   </td><td class="markdownTableBodyNone"><code>comQueueSend</code>   </td><td class="markdownTableBodyNone"><code>Fw.Com</code>   </td><td class="markdownTableBodyNone"><a class="el" href="class_fw_1_1_com_buffer.html">Fw::ComBuffer</a> output port    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>output</code>   </td><td class="markdownTableBodyNone"><code>buffQueueSend</code>   </td><td class="markdownTableBodyNone"><code>Fw.BufferSend</code>   </td><td class="markdownTableBodyNone"><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a> output port    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>async input</code>   </td><td class="markdownTableBodyNone"><code>comStatusIn</code>   </td><td class="markdownTableBodyNone"><code>Fw.SuccessCondition</code>   </td><td class="markdownTableBodyNone">Port for receiving the status signal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>async input</code>   </td><td class="markdownTableBodyNone"><code>comQueueIn</code>   </td><td class="markdownTableBodyNone"><code>[ComQueueComPorts] Fw.Com</code>   </td><td class="markdownTableBodyNone">Port array for receiving Fw::ComBuffers    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>async input</code>   </td><td class="markdownTableBodyNone"><code>buffQueueIn</code>   </td><td class="markdownTableBodyNone"><code>[ComQueueBufferPorts] Fw.BufferSend</code>   </td><td class="markdownTableBodyNone">Port array for receiving Fw::Buffers    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>async input</code>   </td><td class="markdownTableBodyNone"><code>run</code>   </td><td class="markdownTableBodyNone"><code>Svc.Sched</code>   </td><td class="markdownTableBodyNone">Port for scheduling telemetry output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>event</code>   </td><td class="markdownTableBodyNone"><code>Log</code>   </td><td class="markdownTableBodyNone"><code>Fw.Log</code>   </td><td class="markdownTableBodyNone">Port for emitting events    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>text event</code>   </td><td class="markdownTableBodyNone"><code>LogText</code>   </td><td class="markdownTableBodyNone"><code>Fw.LogText</code>   </td><td class="markdownTableBodyNone">Port for emitting text events    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>time get</code>   </td><td class="markdownTableBodyNone"><code>Time</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_fw_1_1_time.html">Fw.Time</a></code>   </td><td class="markdownTableBodyNone">Port for getting the time    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>telemetry</code>   </td><td class="markdownTableBodyNone"><code>Tlm</code>   </td><td class="markdownTableBodyNone"><code>Fw.Tlm</code>   </td><td class="markdownTableBodyNone">Port for emitting telemetry   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md345"></a>
4.2. State</h3>
<p><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> maintains the following state:</p><ol type="1">
<li><code>m_queues</code>: An array of <code><a class="el" href="class_types_1_1_queue.html">Types::Queue</a></code> used to queue per-port messages.</li>
<li><code>m_prioritizedList</code>: An instance of <code>Svc::ComQueue::QueueMetadata</code> storing the priority-order queue metadata.</li>
<li><code>m_state</code>: Instance of <code>Svc::ComQueue::SendState</code> representing the state of the component. See: 4.3.1 State Machine</li>
<li><code>m_throttle</code>: An array of flags that throttle the per-port queue overflow messages.</li>
</ol>
<h3><a class="anchor" id="autotoc_md346"></a>
4.2.1 State Machine</h3>
<p>The <code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> component runs the following state machine. It has two states:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">State   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">WAITING   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> is waiting on <code>SUCCESS</code> before attempting to send an available buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">READY   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> had no queued buffers and will send the next buffer immediately when received   </td></tr>
</table>
<p>The state machine will transition between states when a status is received and will transition from <code>READY</code> when a new buffer is received. <code>FAILURE</code> statuses keep the <code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> in <code>WAITING</code> state whereas a <code>SUCCESS</code> status will either send a buffer and transition to <code>WAITING</code> or will have no buffers to send and will transition into <code>READY</code> state. Buffers are queued when in <code>WAITING</code> state.</p>
<p><img src="./img/state-machine.png" alt="`Svc::ComQueue` Functional State Machine" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md347"></a>
4.3 Model Configuration</h3>
<p><code><a class="el" href="class_svc_1_1_com_queue.html">Svc::ComQueue</a></code> has the following constants, that are configured in <code>AcConstants.fpp</code>:</p><ol type="1">
<li><code>ComQueueComPorts</code>: number of ports of <code>Fw.Com</code> type in the <code>comQueueIn</code> port array.</li>
<li><code>ComQueueBufferPorts</code>: number of ports of <code>Fw.BufferSend</code> type in the <code>buffQueueIn</code> port array.</li>
</ol>
<h3><a class="anchor" id="autotoc_md348"></a>
4.4 Runtime Setup</h3>
<p>To set up an instance of <code>ComQueue</code>, the following needs to be done:</p><ol type="1">
<li>Call the constructor and the init method in the usual way for an F Prime active component.</li>
<li>Call the <code>configure</code> method, passing in an array of <code>QueueConfiguration</code> type, the size of the array, and an allocator of <code><a class="el" href="class_fw_1_1_mem_allocator.html">Fw::MemAllocator</a></code>. The <code>configure</code> method foes the following:<ol type="a">
<li>Ensures that the total size and config size are the same value</li>
<li>Ensures that priority values range from 0 to the total size value</li>
<li>Ensures that every entry in the queue containing the prioritized order of the com buffer and buffer data have been initialized.</li>
<li>Ensures that there is enough memory for the com buffer and buffer data we want to process</li>
</ol>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md349"></a>
4.5 Port Handlers</h3>
<h4><a class="anchor" id="autotoc_md350"></a>
4.5.1 buffQueueIn</h4>
<p>The <code>buffQueueIn</code> port handler receives an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> data type and a port number. It does the following:</p><ol type="1">
<li>Ensures that the port number is between zero and the value of the buffer size</li>
<li>Enqueue the buffer onto the <code>m_queues</code> instance</li>
<li>Returns a warning if <code>m_queues</code> is full</li>
</ol>
<p>In the case where the component is already in <code>READY</code> state, this will process the queue immediately after the buffer is added to the queue.</p>
<h4><a class="anchor" id="autotoc_md351"></a>
4.5.2 comQueueIn</h4>
<p>The <code>comQueueIn</code> port handler receives an <code><a class="el" href="class_fw_1_1_com_buffer.html">Fw::ComBuffer</a></code> data type and a port number. It does the following:</p><ol type="1">
<li>Ensures that the port number is between zero and the value of the com buffer size</li>
<li>Enqueue the com buffer onto the <code>m_queues</code> instance</li>
<li>Returns a warning if <code>m_queues</code> is full</li>
</ol>
<p>In the case where the component is already in <code>READY</code> state, this will process the queue immediately after the buffer is added to the queue.</p>
<h4><a class="anchor" id="autotoc_md352"></a>
4.5.3 comStatusIn</h4>
<p>The <code>comStatusIn</code> port handler receives a <code>Fw::Success</code> status. This triggers the component's state machine to change state. For a full description see <a href="#4.2.1-State-Machine">4.2.1 State Machine</a>.</p>
<h4><a class="anchor" id="autotoc_md353"></a>
4.5.4 run</h4>
<p>The <code>run</code> port handler does the following:</p><ol type="1">
<li>Report the high-water mark for each queue since last <code>run</code> invocation via telemetry</li>
<li>Clear each queue's high-water mark</li>
</ol>
<h3><a class="anchor" id="autotoc_md354"></a>
4.6 Telemetry</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">comQueueDepth   </td><td class="markdownTableBodyNone">Svc.ComQueueDepth   </td><td class="markdownTableBodyNone">High-water mark depths of queues handling <code><a class="el" href="class_fw_1_1_com_buffer.html">Fw::ComBuffer</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">buffQueueDepth   </td><td class="markdownTableBodyNone">Svc.BuffQueueDepth   </td><td class="markdownTableBodyNone">High-water mark depths of queues handling <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code>   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md355"></a>
4.7 Events</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">QueueOverflow   </td><td class="markdownTableBodyNone">WARNING_HI event triggered when a queue can no longer hold the incoming message   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md356"></a>
4.8 Helper Functions</h3>
<h4><a class="anchor" id="autotoc_md357"></a>
4.8.1 sendComBuffer</h4>
<p>Stores the com buffer message, sends the com buffer message on the output port, and then sets the send state to waiting.</p>
<h4><a class="anchor" id="autotoc_md358"></a>
4.8.2 sendBuffer</h4>
<p>Stores the buffer message, sends the buffer message on the output port, and then sets the send state to waiting.</p>
<h4><a class="anchor" id="autotoc_md359"></a>
4.8.3 processQueue</h4>
<p>In a bounded loop that is constrained by the total size of the queue that contains both buffer and com buffer data, do:</p>
<ol type="1">
<li>Check if there are any items on the queue, and continue with the loop if there are none.</li>
<li>Store the entry point of the queue based on the index of the array that contains the prioritized data.</li>
<li>Compare the entry index with the value of the size of the queue that contains com buffer data.<ol type="a">
<li>If it is less than the size value, then invoke the sendComBuffer function.</li>
<li>If it is greater than the size value, then invoke the sendBuffer function.</li>
</ol>
</li>
<li>Break out of the loop, but enter a new loop that starts at the next entry and linearly swap the remaining items in the prioritized list. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
