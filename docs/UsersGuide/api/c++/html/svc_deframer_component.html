<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Svc::Deframer Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">Latest</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_svc_deframer_component.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a> Component </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md363"></a>
Svc::Deframer (Passive Component)</h1>
<h2><a class="anchor" id="autotoc_md364"></a>
1. Introduction</h2>
<p><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> is a passive component. It accepts as input a sequence of byte buffers, which typically come from a ground data system via a ../../../Drv/ByteStreamDriverModel/docs/sdd.md "byte stream driver". It interprets the concatenated data of the buffers as a sequence of uplink frames. The uplink frames need not be aligned on the buffer boundaries, and each frame may span one or more buffers. <code>Deframer</code> extracts the frames from the sequence of buffers. For each complete frame <em>F</em> received, <code>Deframer</code> validates <em>F</em> and extracts a data packet from <em>F</em>. It sends the data packet to another component in the service layer, e.g., an instance of ../../CmdDispatcher/docs/sdd.md "`Svc::CommandDispatcher`", ../../FileUplink/docs/sdd.md "`Svc::FileUplink`", or ../../GenericHub/docs/sdd.md "`Svc::GenericHub`".</p>
<p>When instantiating Deframer, you must provide an implementation of ../../FramingProtocol/docs/sdd.md "`Svc::DeframingProtocol`". This implementation specifies exactly what is in each frame; typically it is a frame header, a data packet, and a hash value.</p>
<p>On receiving a buffer <em>FB</em> containing framed data, <code>Deframer</code> (1) copies the data from <em>FB</em> into a circular buffer <em>CB</em> owned by <code>Deframer</code> and (2) calls the <code>deframe</code> method of the <code><a class="el" href="class_svc_1_1_deframing_protocol.html" title="Abstract base class representing a deframing protocol.">Svc::DeframingProtocol</a></code> implementation, passing a reference to <em>CB</em> as input. If <em>FB</em> holds more data than will fit in <em>CB</em>, then <code>Deframer</code> repeats this process until <em>FB</em> is empty. If the protocol implementation reports that the data in <em>CB</em> represents an incomplete frame, then <code>Deframer</code> postpones deframing until the next buffer <em>FB</em> becomes available.</p>
<p>Deframer supports two configurations for streaming data:</p>
<ol type="1">
<li><b>Poll:</b> This configuration works with a passive byte stream driver. In this configuration, <code>Deframer</code> polls the driver for buffers on its <code>schedIn</code> cycle. No buffer allocation occurs when polling. <em>FB</em> is a buffer owned by <code>Deframer</code>.</li>
<li><b>Push:</b> This configuration works with an active byte stream driver. In this configuration the driver invokes a guarded port of <code>Deframer</code> to send a buffer <em>FB</em> to <code>Deframer</code>. The invocation transfers ownership of <em>FB</em> from the driver to <code>Deframer</code>. Deframing occurs on the thread of the byte stream driver. <code>Deframer</code> deallocates <em>FB</em> before it returns from the guarded port call.</li>
</ol>
<h2><a class="anchor" id="autotoc_md365"></a>
2. Assumptions</h2>
<ol type="1">
<li>For any deployment <em>D</em> that uses an instance <em>I</em> of <code>Deframer</code>, the deframing protocol used with <em>I</em> matches the uplink protocol of any ground system that sends frames to <em>I</em>.</li>
</ol>
<ol type="1">
<li>In any topology <em>T</em>, for any instance <em>I</em> of <code>Deframer</code> in <em>T</em>, at any one time, framed data arrives on the poll interface of <em>I</em> or on the push interface of <em>I</em>, but not on both concurrently. The push and poll interfaces are guarded by a mutual exclusion lock, so there is no concurrency safety issue. However, ordinarily it does not make sense to interleave framed data concurrently on two different interfaces.</li>
</ol>
<ol type="1">
<li>Each frame received by <code>Deframer</code> contains an F Prime command packet or file packet <em>P</em>. The first <em>n</em> bytes of the packet hold the packet descriptor value <code><a class="el" href="class_fw_1_1_com_packet.html#a715f7261d313574f50a43b12914db425ab20fd5c2a3a03493f0b959db4f1ca0a1">Fw::ComPacket::FW_PACKET_COMMAND</a></code> (for a command packet) or <code><a class="el" href="class_fw_1_1_com_packet.html#a715f7261d313574f50a43b12914db425a2af3697dc87c65b5561ac143e7197189">Fw::ComPacket::FW_PACKET_FILE</a></code> (for a file packet), serialized as an unsigned integer in big-endian byte order. The number of bytes <em>n</em> matches the size of the type defined by the C preprocessor symbol <code>FwPacketDescriptorType</code> in the F Prime FSW.</li>
</ol>
<h2><a class="anchor" id="autotoc_md366"></a>
3. Requirements</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Requirement </th><th class="markdownTableHeadNone">Description </th><th class="markdownTableHeadNone">Rationale </th><th class="markdownTableHeadNone">Verification Method  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-DEFRAMER-001 </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall accept a sequence of byte buffers and interpret their concatenated data as a sequence of uplink frames. </td><td class="markdownTableBodyNone">The purpose of the component is to do uplink deframing. </td><td class="markdownTableBodyNone">Unit test  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SVC-DEFRAMER-002 </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall accept byte buffers containing uplink frames that are not aligned on a buffer boundary. </td><td class="markdownTableBodyNone">For flexibility, we do not require that the frames be aligned on a buffer boundary. </td><td class="markdownTableBodyNone">Unit test  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-DEFRAMER-003 </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall accept byte buffers containing uplink frames that span one or more buffers. </td><td class="markdownTableBodyNone">For flexibility, we do not require each frame to fit in a single buffer. </td><td class="markdownTableBodyNone">Unit test  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SVC-DEFRAMER-004 </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall provide a port interface that a threaded driver can use to push byte buffers to be deframed. </td><td class="markdownTableBodyNone">This interface supports applications in which the byte stream driver has its own thread. </td><td class="markdownTableBodyNone">Unit test  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-DEFRAMER-005 </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall provide a port interface that Deframer can use to poll for byte buffers to be deframed. </td><td class="markdownTableBodyNone">This interface supports applications in which byte stream driver does not have its own thread. </td><td class="markdownTableBodyNone">Unit test  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SVC-DEFRAMER-006 </td><td class="markdownTableBodyNone">If the polling interface is connected, then <code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall poll for byte buffers on its <code>schedIn</code> port. </td><td class="markdownTableBodyNone">This requirement allows the system scheduler to drive the periodic polling. </td><td class="markdownTableBodyNone">Unit test  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-DEFRAMER-007 </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall use an instance of <code><a class="el" href="class_svc_1_1_deframing_protocol.html" title="Abstract base class representing a deframing protocol.">Svc::DeframingProtocol</a></code>, supplied when the component is instantiated, to validate the frames and extract their packet data. </td><td class="markdownTableBodyNone">Using the <code><a class="el" href="class_svc_1_1_deframing_protocol.html" title="Abstract base class representing a deframing protocol.">Svc::DeframingProtocol</a></code> interface allows the same Deframer component to operate with different protocols. </td><td class="markdownTableBodyNone">Unit test  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SVC-DEFRAMER-008 </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall interpret the initial bytes of the packet data as a value of type <code>FwPacketDescriptorType</code>. </td><td class="markdownTableBodyNone"><code>FwPacketDescriptorType</code> is the type of an F Prime packet descriptor. The size of the type is configurable in the F Prime framework. </td><td class="markdownTableBodyNone">Test  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-DEFRAMER-009 </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall extract and send packets with the following types: <code><a class="el" href="class_fw_1_1_com_packet.html#a715f7261d313574f50a43b12914db425ab20fd5c2a3a03493f0b959db4f1ca0a1">Fw::ComPacket::FW_PACKET_COMMAND</a></code>, <code><a class="el" href="class_fw_1_1_com_packet.html#a715f7261d313574f50a43b12914db425a2af3697dc87c65b5561ac143e7197189">Fw::ComPacket::FW_PACKET_FILE</a></code>. </td><td class="markdownTableBodyNone">These are the packet types used for uplink. </td><td class="markdownTableBodyNone">Unit test  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SVC-DEFRAMER-010 </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall send command packets and file packets on separate ports. </td><td class="markdownTableBodyNone">Command packets and file packets are typically handled by different components. </td><td class="markdownTableBodyNone">Unit test  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SVC-DEFRAMER-011 </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> shall operate nominally when its port for sending file packets is unconnected, even if it receives a frame containing a file packet. </td><td class="markdownTableBodyNone">Some applications do not use file uplink. Sending a file uplink packet to <code>Deframer</code> should not crash the application because of an unconnected port. </td><td class="markdownTableBodyNone">Unit test  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md367"></a>
4. Design</h2>
<h3><a class="anchor" id="autotoc_md368"></a>
4.1. Component Diagram</h3>
<p>The diagram below shows the <code>Deframer</code> component.</p>
<div> <img src="img/Deframer.png" alt="" width="700/" class="inline"/> </div><h3><a class="anchor" id="autotoc_md369"></a>
4.2. Ports</h3>
<p><code>Deframer</code> has the following ports:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Kind </th><th class="markdownTableHeadNone">Name </th><th class="markdownTableHeadNone">Port Type </th><th class="markdownTableHeadNone">Usage  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>guarded input</code> </td><td class="markdownTableBodyNone"><code>framedIn</code> </td><td class="markdownTableBodyNone"><code>Drv.ByteStreamRecv</code> </td><td class="markdownTableBodyNone">Port for receiving frame buffers FB pushed from the byte stream driver. After using a buffer FB received on this port, Deframer deallocates it by invoking framedDeallocate.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>output</code> </td><td class="markdownTableBodyNone"><code>framedDeallocate</code> </td><td class="markdownTableBodyNone"><code>Fw.BufferSend</code> </td><td class="markdownTableBodyNone">Port for deallocating buffers received on framedIn.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>guarded input</code> </td><td class="markdownTableBodyNone"><code>schedIn</code> </td><td class="markdownTableBodyNone"><code>Svc.Sched</code> </td><td class="markdownTableBodyNone">Schedule in port, driven by a rate group.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>output</code> </td><td class="markdownTableBodyNone"><code>framedPoll</code> </td><td class="markdownTableBodyNone"><code>Drv.ByteStreamPoll</code> </td><td class="markdownTableBodyNone">Port that polls for data from the byte stream driver. Deframer invokes this port on its schedIn cycle, if it is connected. No allocation or occurs when invoking this port. The data transfer uses a pre-allocated frame buffer owned by Deframer.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output</code> </td><td class="markdownTableBodyNone"><code>bufferAllocate</code> </td><td class="markdownTableBodyNone"><code>Fw.BufferGet</code> </td><td class="markdownTableBodyNone">Port for allocating <a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a> objects from a buffer manager. When Deframer invokes this port, it receives a packet buffer PB and takes ownership of it. It uses PB internally for deframing. Then one of two things happens: 1. PB contains a file packet, which Deframer sends on bufferOut. In this case ownership of PB passes to the receiver. 2. PB does not contain a file packet, or bufferOut is unconnected. In this case Deframer deallocates PB on bufferDeallocate.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>output</code> </td><td class="markdownTableBodyNone"><code>bufferOut</code> </td><td class="markdownTableBodyNone"><code>Fw.BufferSend</code> </td><td class="markdownTableBodyNone">Port for sending file packets (case 1 above). The file packets are wrapped in <a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a> objects allocated with bufferAllocate. Ownership of the <a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a> passes to the receiver, which is responsible for the deallocation.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output</code> </td><td class="markdownTableBodyNone"><code>bufferDeallocate</code> </td><td class="markdownTableBodyNone"><code>Fw.BufferSend</code> </td><td class="markdownTableBodyNone">Port for deallocating temporary buffers allocated with bufferAllocate (case 2 above). Deallocation occurs here when there is nothing to send on bufferOut.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>output</code> </td><td class="markdownTableBodyNone"><code>comOut</code> </td><td class="markdownTableBodyNone"><code>Fw.Com</code> </td><td class="markdownTableBodyNone">Port for sending command packets as Com buffers.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sync input</code> </td><td class="markdownTableBodyNone"><code>cmdResponseIn</code> </td><td class="markdownTableBodyNone"><code>Fw.CmdResponse</code> </td><td class="markdownTableBodyNone">Port for receiving command responses from a command dispatcher. Invoking this port does nothing. The port exists to allow the matching connection in the topology.  </td></tr>
</table>
<p><a class="anchor" id="derived-classes"></a> </p>
<h3><a class="anchor" id="autotoc_md370"></a>
4.3. Derived Classes</h3>
<p><code>Deframer</code> is derived from <code>DeframerComponentBase</code> as usual. It is also derived (via C++ multiple inheritance) from ../../FramingProtocol/docs/sdd.md "`Svc::DeframingProtocolInterface`". The multiple inheritance makes the <code>Deframer</code> instance into the instance of <code><a class="el" href="class_svc_1_1_deframing_protocol_interface.html" title="interface supplied to the deframing protocol">Svc::DeframingProtocolInterface</a></code> that is required to use <code><a class="el" href="class_svc_1_1_deframing_protocol.html" title="Abstract base class representing a deframing protocol.">Svc::DeframingProtocol</a></code>. See <a href="#dpi-impl">below</a> for a description of how <code>Deframer</code> implements <code>DeframingProtocolInterface</code>.</p>
<p>Here is a class diagram for <code>Deframer</code>:</p>
<div class="fragment"><div class="line">classDiagram</div>
<div class="line">    ObjBase &lt;|-- PassiveComponentBase</div>
<div class="line">    PassiveComponentBase &lt;|-- DeframerComponentBase</div>
<div class="line">    DeframerComponentBase &lt;|-- Deframer</div>
<div class="line">    DeframingProtocolInterface &lt;|-- Deframer</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md371"></a>
4.4. State</h3>
<p><code>Deframer</code> maintains the following state:</p>
<ol type="1">
<li><code>m_protocol</code>: A pointer to the implementation of <code>DeframingProtocol</code> used for deframing.</li>
</ol>
<ol type="1">
<li><code>m_inRing</code>: An instance of <code><a class="el" href="class_types_1_1_circular_buffer.html">Types::CircularBuffer</a></code> for storing data to be deframed.</li>
</ol>
<ol type="1">
<li><code>m_ringBuffer</code>: The storage backing the circular buffer: an array of <code>RING_BUFFER_SIZE</code> <code>U8</code> values.</li>
</ol>
<ol type="1">
<li><code>m_pollBuffer</code>: The buffer used for polling input: an array of 1024 <code>POLL_BUFFER_SIZE</code> values.</li>
</ol>
<h3><a class="anchor" id="autotoc_md372"></a>
4.5. Header File Configuration</h3>
<p>The <code>Deframer</code> header file provides the following configurable constants:</p>
<ol type="1">
<li><code>Svc::Deframer::RING_BUFFER_SIZE</code>: The size of the circular buffer. The capacity of the circular buffer must be large enough to hold a complete frame.</li>
</ol>
<ol type="1">
<li><code>Svc::Deframer::POLL_BUFFER_SIZE</code>: The size of the buffer used for polling data.</li>
</ol>
<h3><a class="anchor" id="autotoc_md373"></a>
4.6. Runtime Setup</h3>
<p>To set up an instance of <code>Deframer</code>, you do the following:</p>
<ol type="1">
<li>Call the constructor and the <code>init</code> method in the usual way for an F Prime passive component.</li>
</ol>
<ol type="1">
<li>Call the <code>setup</code> method, passing in an instance <em>P</em> of <code><a class="el" href="class_svc_1_1_deframing_protocol.html" title="Abstract base class representing a deframing protocol.">Svc::DeframingProtocol</a></code>. The <code>setup</code> method does the following:<ol type="a">
<li>Store a pointer to <em>P</em> in <code>m_protocol</code>.</li>
</ol>
<ol type="a">
<li>Pass <code>*this</code> into the setup method for <em>P</em>. As noted <a href="#derived-classes">above</a>, <code>*this</code> is the instance of <code><a class="el" href="class_svc_1_1_deframing_protocol_interface.html" title="interface supplied to the deframing protocol">Svc::DeframingProtocolInterface</a></code> used by <em>P</em>.</li>
</ol>
</li>
</ol>
<p>For an example of setting up a <code>Deframer</code> instance, see the <code>uplink</code> instance in <a href="../../../Ref/Top/instances.fpp"><code>Ref/Top/instances.fpp</code></a>.</p>
<h3><a class="anchor" id="autotoc_md374"></a>
4.7. Port Handlers</h3>
<h4><a class="anchor" id="autotoc_md375"></a>
4.7.1. framedIn</h4>
<p>The <code>framedIn</code> port handler receives an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> <em>FB</em> and a receive status <em>S</em>. It does the following:</p>
<ol type="1">
<li>If <em>S</em> = <code>RECV_OK</code>, then call <a href="#processBuffer"><code>processBuffer</code></a>, passing in <em>FB</em>.</li>
<li>Deallocate <em>FB</em> by invoking <code>framedDeallocate</code>.</li>
</ol>
<h4><a class="anchor" id="autotoc_md376"></a>
4.7.2. schedIn</h4>
<p>The <code>schedIn</code> port handler does the following:</p>
<ol type="1">
<li>Construct an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> <em>FB</em> that wraps <code>m_pollBuffer</code>.</li>
</ol>
<ol type="1">
<li>If <code>framedPoll</code> is connected, then<ol type="a">
<li>Invoke <code>framedPollOut</code>, passing in <em>FB</em>, to poll for new data.</li>
</ol>
<ol type="a">
<li>If new data is available, then call <a href="#processBuffer"><code>processBuffer</code></a>, passing in <em>FB</em>.</li>
</ol>
</li>
</ol>
<h4><a class="anchor" id="autotoc_md377"></a>
4.7.3. cmdResponseIn</h4>
<p>The <code>cmdResponseIn</code> handler does nothing. It exists to provide the necessary symmetry in the topology (every component that sends a command to the dispatcher should accept a matching response).</p>
<p><a class="anchor" id="dpi-impl"></a> </p>
<h3><a class="anchor" id="autotoc_md378"></a>
4.8. Implementation of Svc::DeframingProtocolInterface</h3>
<p><a class="anchor" id="allocate"></a> </p>
<h4><a class="anchor" id="autotoc_md379"></a>
4.8.1. allocate</h4>
<p>The implementation of <code>allocate</code> invokes <code>bufferAllocate</code>.</p>
<p><a class="anchor" id="route"></a> </p>
<h4><a class="anchor" id="autotoc_md380"></a>
4.8.2. route</h4>
<p>The implementation of <code>route</code> takes a reference to an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> <em>PB</em> (a packet buffer) and does the following:</p>
<ol type="1">
<li>Set <code>deallocate = true</code>.</li>
</ol>
<ol type="1">
<li>Let <em>N</em> = <code>sizeof(FwPacketDescriptorType)</code>. Deserialize the first <em>N</em> bytes of <em>PB</em> as a value of type <code>FwPacketDescriptorType</code>.</li>
</ol>
<ol type="1">
<li>If the deserialization succeeds, then switch on the packet type <em>T</em>.<ol type="a">
<li>If <em>T</em> = <code>FW_PACKET_COMMAND</code>, then send the contents of <em>PB</em> as a Com buffer on <code>comOut</code>.</li>
</ol>
<ol type="a">
<li>Otherwise if <em>T</em> = <code>FW_PACKET_FILE</code> and <code>bufferOut</code> is connected, then<ol type="i">
<li>Shift the pointer of <em>PB</em> <em>N</em> bytes forward and reduce the size of <em>PB</em> by <em>N</em> to skip the packet type. This step is necessary to accommodate the <code>FileUplink</code> component.</li>
</ol>
<ol type="i">
<li>Send <em>B</em> on <code>bufferOut</code>.</li>
</ol>
<ol type="i">
<li>Set <code>deallocate = false</code>. This step causes ownership of the buffer to pass to the receiver.</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol type="1">
<li>If <code>deallocate = true</code>, then invoke <code>bufferDeallocate</code> to deallocate <em>PB</em>.</li>
</ol>
<h3><a class="anchor" id="autotoc_md381"></a>
4.9. Helper Functions</h3>
<p><a class="anchor" id="processBuffer"></a> </p>
<h4><a class="anchor" id="autotoc_md382"></a>
4.9.1. processBuffer</h4>
<p><code>processBuffer</code> accepts a reference to an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> <em>FB</em> (a frame buffer). It does the following:</p>
<ol type="1">
<li>Set <code>buffer_offset</code> = 0.</li>
</ol>
<ol type="1">
<li>Set <em>S</em> = <code><a class="el" href="namespace_fpp_test_1_1_string.html#aad0e415a669aa066ffb482cdc3df4f9f">buffer.getSize()</a></code>.</li>
</ol>
<ol type="1">
<li>In a bounded loop, while <code>buffer_offset</code> &lt; <em>S</em>, do:<ol type="a">
<li>Compute the amount of remaining data in <em>FB</em>. This is <em>R</em> = <em>S</em> - <code>buffer_offset</code>.</li>
</ol>
<ol type="a">
<li>Compute <em>C</em>, the number of bytes to copy from <em>FB</em> into the circular buffer <code>m_inRing</code>.<ol type="i">
<li>Let <em>F</em> be the number of free bytes in <code>m_inRing</code>.</li>
</ol>
<ol type="i">
<li>If <em>R</em> &lt; <em>F</em>, then <em>C</em> = <em>R</em>.</li>
</ol>
<ol type="i">
<li>Otherwise <em>C</em> = <em>F</em>.</li>
</ol>
</li>
</ol>
<ol type="a">
<li>Copy <em>C</em> bytes from <em>FB</em> starting at <code>buffer_offset</code> into <code>m_inRing</code>.</li>
</ol>
<ol type="a">
<li>Advance <code>buffer_offset</code> by <em>C</em>.</li>
</ol>
<ol type="a">
<li>Call <a href="#processRing"><code>processRing</code></a> to process the data stored in <code>m_inRing</code>.</li>
</ol>
</li>
</ol>
<p><a class="anchor" id="processRing"></a> </p>
<h4><a class="anchor" id="autotoc_md383"></a>
4.9.2. processRing</h4>
<p>In a bounded loop, while there is data remaining in <code>m_inRing</code>, do:</p>
<ol type="1">
<li>Call the <code>deframe</code> method of <code>m_protocol</code> on <code>m_inRing</code>. The <code>deframe</code> method calls <a href="#allocate"><code>allocate</code></a> and <a href="#route"><code>route</code></a> as necessary. It returns a status value <em>S</em> and the number <em>N</em> of bytes needed for successful deframing.</li>
</ol>
<ol type="1">
<li>If <em>S</em> = <code>SUCCESS</code>, then <em>N</em> represents the number of bytes used in a successful deframing. Rotate <code>m_inRing</code> by <em>N</em> bytes (i.e., deallocate <em>N</em> bytes from the head of <code>m_inRing</code>).</li>
</ol>
<ol type="1">
<li>Otherwise if <em>S</em> = <code>MORE_NEEDED</code>, then do nothing. Further processing will occur on the next call, after more data goes into <code>m_inRing</code>.</li>
</ol>
<ol type="1">
<li>Otherwise something is wrong. Rotate <code>m_inRing</code> by one byte, to skip byte by byte over bad data until we find a valid frame.</li>
</ol>
<h2><a class="anchor" id="autotoc_md384"></a>
5. Ground Interface</h2>
<p>None.</p>
<h2><a class="anchor" id="autotoc_md385"></a>
6. Example Uses</h2>
<p><a class="anchor" id="top-diagrams"></a> </p>
<h3><a class="anchor" id="autotoc_md386"></a>
6.1. Topology Diagrams</h3>
<p>The following topology diagrams show how to connect <code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> to a byte stream driver, a command dispatcher, and a file uplink component. The diagrams use the following instances:</p>
<ul>
<li><code>activeComm</code>: An active instance of ../../../Drv/ByteStreamDriverModel/docs/sdd.md "`Drv::ByteStreamDriverModel`", for example, ../../../Drv/TcpClient/docs/sdd.md "`Drv::TcpClient`".</li>
<li><code>buffMgr</code>: An instance of ../../BufferManager/docs/sdd.md "`Svc::BufferManager`"</li>
<li><code>cmdDisp</code>: An instance of ../../CmdDispatcher/docs/sdd.md "`Svc::CommandDispatcher`"</li>
<li><code>deframer</code>: An instance of <code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code>.</li>
<li><code>fileUplink</code>: An instance of ../../FileUplink/docs/sdd.md "`Svc::FileUplink`".</li>
<li><code>passiveComm</code>: A passive instance of ../../../Drv/ByteStreamDriverModel/docs/sdd.md "`Drv::ByteStreamDriverModel`".</li>
<li><code>rateGroup</code>: An instance of ../../ActiveRateGroup/docs/sdd.md "`Svc::ActiveRateGroup`".</li>
</ul>
<p>Topologies 1a and 1b are alternate topologies. You should use one or the other. In topology 3, the <code>fileUplink</code> instance and its connections are optional.</p>
<p><b>Topology 1a: Buffers containing framed data (active byte stream driver):</b></p>
<div> <img src="img/top/framed-active.png" alt="" width="1000/" class="inline"/> </div><p><b>Topology 1b: Buffers containing framed data (passive byte stream driver):</b></p>
<div> <img src="img/top/framed-passive.png" alt="" width="1000/" class="inline"/> </div><p>Revise the port number of <code>rateGroup.RateGroupMemberOut</code> as appropriate for your application.</p>
<p><b>Topology 2: Command packets and command responses:</b></p>
<div> <img src="img/top/cmd.png" alt="" width="800/" class="inline"/> </div><p>Revise the port numbers of <code>cmdDisp.seqCmdBuff</code> and <code>cmdDisp.compCmdStat</code> as appropriate for your application. If you model your topology in FPP, then FPP can automatically assign these numbers.</p>
<p><b>Topology 3: Buffers containing packet data:</b></p>
<div> <img src="img/top/deframer-file.png" alt="" width="1000/" class="inline"/> </div><h3><a class="anchor" id="autotoc_md387"></a>
6.2. Sequence Diagrams</h3>
<h4><a class="anchor" id="autotoc_md388"></a>
6.2.1. Active Byte Stream Driver</h4>
<p><b>Sending a command packet:</b> The following sequence diagram shows what happens when <code>activeComm</code> sends data to <code>deframer</code>, and <code>deframer</code> decodes the data into a command packet. Open vertical rectangles represent threads. Vertical dashed lines represent component code. Solid horizontal arrows represent synchronous port invocations, and open horizontal arrows represent asynchronous port invocations.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    activate activeComm</div>
<div class="line">    activeComm-&gt;&gt;buffMgr: Allocate frame buffer FB</div>
<div class="line">    buffMgr--&gt;&gt;activeComm: Return FB</div>
<div class="line">    activeComm-&gt;&gt;activeComm: Fill FB with framed data</div>
<div class="line">    activeComm-&gt;&gt;deframer: Send FB[framedIn]</div>
<div class="line">    deframer-&gt;&gt;buffMgr: Allocate packet buffer PB [bufferAllocate]</div>
<div class="line">    buffMgr--&gt;&gt;deframer: Return PB</div>
<div class="line">    deframer-&gt;&gt;deframer: Deframe FB into PB</div>
<div class="line">    deframer-&gt;&gt;deframer: Copy PB into a command packet C</div>
<div class="line">    deframer-)cmdDisp: Send C [comOut]</div>
<div class="line">    deframer-&gt;&gt;buffMgr: Deallocate PB [bufferDeallocate]</div>
<div class="line">    buffMgr--&gt;&gt;deframer: </div>
<div class="line">    deframer-&gt;&gt;buffMgr: Deallocate FB [framedDeallocate]</div>
<div class="line">    buffMgr--&gt;&gt;deframer: </div>
<div class="line">    deframer--&gt;&gt;activeComm: </div>
<div class="line">    deactivate  activeComm </div>
<div class="line">    activate cmdDisp</div>
<div class="line">    cmdDisp-&gt;&gt;deframer: Send cmd response [cmdResponseIn]</div>
<div class="line">    deframer--&gt;&gt;cmdDisp: </div>
<div class="line">    deactivate cmdDisp</div>
</div><!-- fragment --><p><b>Sending a file packet:</b> The following sequence diagram shows what happens when <code>activeComm</code> sends data to <code>deframer</code>, and <code>deframer</code> decodes the data into a file packet.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    activate activeComm</div>
<div class="line">    activeComm-&gt;&gt;buffMgr: Allocate frame buffer FB</div>
<div class="line">    buffMgr--&gt;&gt;activeComm: Return FB</div>
<div class="line">    activeComm-&gt;&gt;activeComm: Fill FB with framed data</div>
<div class="line">    activeComm-&gt;&gt;deframer: Send FB [framedIn]</div>
<div class="line">    deframer-&gt;&gt;buffMgr: Allocate packet buffer PB [bufferAllocate]</div>
<div class="line">    buffMgr--&gt;&gt;deframer: Return PB</div>
<div class="line">    deframer-&gt;&gt;deframer: Deframe FB into PB</div>
<div class="line">    deframer-)fileUplink: Send PB [bufferOut]</div>
<div class="line">    deframer-&gt;&gt;buffMgr: Deallocate FB [framedDeallocate]</div>
<div class="line">    buffMgr--&gt;&gt;deframer: </div>
<div class="line">    deframer--&gt;&gt;activeComm: </div>
<div class="line">    deactivate activeComm</div>
<div class="line">    activate fileUplink</div>
<div class="line">    fileUplink-&gt;&gt;buffMgr: Deallocate PB</div>
<div class="line">    buffMgr--&gt;&gt;fileUplink: </div>
<div class="line">    deactivate fileUplink</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md389"></a>
6.2.2. Passive Byte Stream Driver</h4>
<p><b>Sending a command packet:</b> The following sequence diagram shows what happens when <code>passiveComm</code> sends data to <code>deframer</code>, and <code>deframer</code> decodes the data into a command packet.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    activate rateGroup</div>
<div class="line">    rateGroup-&gt;&gt;deframer: Send schedule tick [schedIn]</div>
<div class="line">    deframer-&gt;&gt;passiveComm: Poll for data [framedPoll]</div>
<div class="line">    passiveComm--&gt;&gt;deframer: Return status</div>
<div class="line">    deframer-&gt;&gt;buffMgr: Allocate packet buffer PB [bufferAllocate]</div>
<div class="line">    buffMgr--&gt;&gt;deframer: Return PB</div>
<div class="line">    deframer-&gt;&gt;deframer: Deframe data into PB</div>
<div class="line">    deframer-&gt;&gt;deframer: Copy PB into a command packet C</div>
<div class="line">    deframer-)cmdDisp: Send C [comOut]</div>
<div class="line">    deframer-&gt;&gt;buffMgr: Deallocate PB [bufferDeallocate]</div>
<div class="line">    buffMgr--&gt;&gt;deframer: </div>
<div class="line">    deframer--&gt;&gt;rateGroup: </div>
<div class="line">    deactivate rateGroup</div>
<div class="line">    activate cmdDisp</div>
<div class="line">    cmdDisp-&gt;&gt;deframer: Send cmd response [cmdResponseIn]</div>
<div class="line">    deframer--&gt;&gt;cmdDisp: </div>
<div class="line">    deactivate cmdDisp </div>
</div><!-- fragment --><p><b>Sending a file packet:</b> The following sequence diagram shows what happens when <code>passiveComm</code> sends data to <code>deframer</code>, and <code>Deframer</code> decodes the data into a file packet.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    activate rateGroup</div>
<div class="line">    rateGroup-&gt;&gt;deframer: Send schedule tick [schedIn]</div>
<div class="line">    deframer-&gt;&gt;passiveComm: Poll for data [framedPoll]</div>
<div class="line">    passiveComm--&gt;&gt;deframer: Return status</div>
<div class="line">    deframer-&gt;&gt;buffMgr: Allocate packet buffer PB [bufferAllocate]</div>
<div class="line">    buffMgr--&gt;&gt;deframer: Return PB</div>
<div class="line">    deframer-&gt;&gt;deframer: Deframe data into PB</div>
<div class="line">    deframer-)fileUplink: Send PB [bufferOut]</div>
<div class="line">    deframer--&gt;&gt;rateGroup: </div>
<div class="line">    deactivate rateGroup</div>
<div class="line">    activate fileUplink</div>
<div class="line">    fileUplink-&gt;&gt;buffMgr: Deallocate PB</div>
<div class="line">    buffMgr--&gt;&gt;fileUplink: </div>
<div class="line">    deactivate fileUplink</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md390"></a>
6.3. Using Svc::GenericHub</h3>
<p>You can use <code>Deframer</code> with an instance of ../../GenericHub/docs/sdd.md "`Svc::GenericHub`" to send deframed command packets and file packets across a network connection, instead of directly to a command dispatcher or file uplink component. To send deframed packets this way, do the following:</p>
<ol type="1">
<li>In the topology described <a href="#top-diagrams">above</a>, instead of the <code>cmdDisp</code> and <code>fileUplink</code> instances, use an instance <code>hub</code> of type <code><a class="el" href="namespace_svc.html#a2726e21edb6ef5238cd546d94c01c0fa">Svc::GenericHub</a></code>.</li>
</ol>
<ol type="1">
<li>Revise topologies 2 and 3 as shown below.</li>
</ol>
<p><b>Topology 2: Command packets</b></p>
<div> <img src="img/top/hub-cmd.png" alt="" width="800/" class="inline"/> </div><p>Revise the port number of <code>hub.portIn</code> as appropriate for your application.</p>
<p><b>Topology 3: Buffers containing packet data</b></p>
<div> <img src="img/top/hub-file.png" alt="" width="1000/" class="inline"/> </div><p>Revise the port number of <code>hub.buffersIn</code> as appropriate for your application. When <code>hub</code> receives a buffer on <code>buffersIn</code>, it copies the data across the connection to the other hub and deallocates the buffer.</p>
<p>If you don't need to transmit file packets across the hub, then you can omit the <code>hub</code> connections shown in this topology.</p>
<h2><a class="anchor" id="autotoc_md391"></a>
7. Change Log</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Date </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2021-01-30 </td><td class="markdownTableBodyNone">Initial Draft  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2022-04-04 </td><td class="markdownTableBodyNone">Revised  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="svc.html">Svc Components, Ports, and Classes</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
